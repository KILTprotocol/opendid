use actix_web::{get, post, web, App, HttpResponse, HttpServer, Responder, Error, cookie::SameSite};
use actix_session::{Session, SessionMiddleware, storage::CookieSessionStore, config::CookieContentSecurity};
use actix_web::cookie::Key;
use actix_cors::Cors;

use rand::Rng;
use serde::{Serialize, Deserialize};
use base58::{FromBase58};
use sodiumoxide::crypto::box_;

mod kilt;
use kilt::{connect};
use sp_core::Pair;

const DAPP_NAME: &str = "My DApp";
const DAPP_ENCRYPTION_KEY_URI: &str = "did:kilt:4siDmerNEBREZJsFoLM95x6cxEho73bCWKEDAXrKdou4a3mH#0x434c5a3c5d6c042a117abd47b9dae9c49fd6d023ecdd17ff5d910a2916a1dbd1";

// shared state
struct AppState {
    app_name: String,
    encryption_key_uri: String,
    public_key: Vec<u8>,
    secret_key: Vec<u8>,
}

// Data that the user receives when starting a session
#[derive(Clone, Debug, Serialize, Deserialize)]
struct ChallengeData {
    #[serde(rename = "dAppName")]
    app_name: String,
    #[serde(rename = "dAppEncryptionKeyUri")]
    encryption_key_uri: String,
    challenge: String,
}

impl ChallengeData {
    fn new(app_name: &str, encryption_key_uri: &str) -> Self {
        let mut rng = rand::thread_rng();
        let challenge: [u8; 32] = rng.gen();
        let challenge_hex = hex::encode(challenge);
        Self {
            app_name: app_name.to_string(),
            encryption_key_uri: encryption_key_uri.to_string(),
            challenge: challenge_hex,
        }
    }
}

// Data that the user passes back to us when starting a session
#[derive(Clone, Debug, Serialize, Deserialize)]
struct ChallengeResponse {
    #[serde(rename = "encryptionKeyUri")]
    encryption_key_uri: String,
    #[serde(rename = "encryptedChallenge")]
    encrypted_challenge: String,
    nonce: String,
}

// GET /api/v1/challenge -> create a new challenge, store it in the cookies and send it to the user
#[get("/api/v1/challenge")]
async fn challenge_handler(session: Session, app_state: web::Data<AppState>) -> impl Responder {
    let challenge_data = ChallengeData::new(&app_state.app_name, &app_state.encryption_key_uri);
    session.insert("challenge", challenge_data.clone()).unwrap();
    HttpResponse::Ok().json(challenge_data)
}

// POST /api/v1/challenge -> check the challenge response and start a session
#[post("/api/v1/challenge")]
async fn challenge_response_handler(session: Session, app_state: web::Data<AppState>, challenge_response: web::Json<ChallengeResponse>) -> impl Responder {
    let session_challenge = match session.get::<ChallengeData>("challenge") {
        Ok(Some(data)) => data.challenge,
        _ => return HttpResponse::Unauthorized().body("No challenge"),
    };
    let session_challenge_bytes = match hex::decode(session_challenge.trim_start_matches("0x")) {
        Ok(bytes) => bytes,
        _ => return HttpResponse::Unauthorized().body("Invalid challenge"),
    };
    let nonce = match hex::decode(&challenge_response.nonce.trim_start_matches("0x")) {
        Ok(nonce) => nonce,
        _ => return HttpResponse::Unauthorized().body("Invalid nonce"),
    };
    let encrypted_challenge = match hex::decode(&challenge_response.encrypted_challenge.trim_start_matches("0x")) {
        Ok(encrypted_challenge) => encrypted_challenge,
        _ => return HttpResponse::Unauthorized().body("Invalid encrypted challenge"),
    };
    let others_pubkey = match parse_encryption_key_from_lightdid(challenge_response.encryption_key_uri.as_str()) {
        Ok(key) => key,
        _ => return HttpResponse::Unauthorized().body("Invalid encryption key"),
    };
    let our_secretkey = app_state.secret_key.clone();
    let nonce = box_::Nonce::from_slice(&nonce).unwrap();
    let pk = box_::PublicKey::from_slice(&others_pubkey).unwrap();
    let sk = box_::SecretKey::from_slice(&our_secretkey).unwrap();
    let decrypted_challenge = match box_::open(&encrypted_challenge, &nonce, &pk, &sk) {
        Ok(decrypted_challenge) => decrypted_challenge,
        _ => return HttpResponse::Unauthorized().body("Could not decrypt challenge"),
    };
    if session_challenge_bytes == decrypted_challenge {
        session.insert("auth", true).unwrap();
        HttpResponse::Ok().body("Challenge accepted")
    } else {
        HttpResponse::Unauthorized().body("Wrong challenge")
    }
}

fn get_key_from_env() -> Key {
    // check SESSION_KEY env variable
    if let Ok(key) = std::env::var("SESSION_KEY") {
        return Key::derive_from(key.as_bytes());
    } else {
        // generate random key
        return Key::generate();
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
struct LightDidKeyDetails {
    #[serde(rename = "publicKey")]
    public_key: Vec<u8>,
    #[serde(rename = "type")]
    type_: String,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
struct LightDidDetails {
    e: LightDidKeyDetails,
}

fn parse_encryption_key_from_lightdid(did: &str) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
    // example did:kilt:light:00${authAddress}:${details}#encryption
    let mut parts = did.split("#");
    let first = parts.next().ok_or("malformed")?;
    let mut parts = first.split(":");
    let _ = parts.next().ok_or("malformed")?;
    let _ = parts.next().ok_or("malformed")?;
    let _ = parts.next().ok_or("malformed")?;

    let details = parts.next().ok_or("malformed")?;
    let bs: Vec<u8> = FromBase58::from_base58(details).map_err(|_|"malformed base58")?;
    let details: LightDidDetails = serde_cbor::from_slice(&bs.as_slice()[1..])?;
    return Ok(details.e.public_key)
}

#[actix_web::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {

    let matches = clap::Command::new("kiltlogin")
        .arg(clap::Arg::new("seed")
            .short('s')
            .long("seed")
            .value_name("SEED")
            .help("Sets the encryption key seed")
        )
        .arg(clap::Arg::new("key_uri")
            .short('k')
            .long("key-uri")
            .value_name("KEY_URI")
            .help("Sets the encryption key uri")
        )
        .get_matches();

    let seed = matches.get_one::<String>("seed").unwrap();
    let key_uri = matches.get_one::<String>("key_uri").unwrap();

    let pair = sp_core::sr25519::Pair::from_string_with_seed(seed, None)?.0;
    let schnorrkel_pair = schnorrkel::Keypair::from(pair);
    let seed = sp_core::blake2_256(&schnorrkel_pair.secret.to_bytes());
    let (ourPublicKey, ourSecretKey) = box_::keypair_from_seed(&box_::Seed::from_slice(&seed).ok_or("bad seed")?);
    
    let state = AppState {
        app_name: "kiltlogin".to_string(),
        encryption_key_uri: key_uri.to_string(),
        public_key: ourPublicKey.0.to_vec(),
        secret_key: ourSecretKey.0.to_vec(),
    };

    HttpServer::new(|| {
        App::new()
            .app_data(web::Data::new(state))
            .wrap(
                Cors::permissive()
            )
            .wrap(
                SessionMiddleware::builder(
                    CookieSessionStore::default(),
                    get_key_from_env(),
                )
                .cookie_content_security(CookieContentSecurity::Private)
                .cookie_same_site(SameSite::None)
                .cookie_secure(true)
                .build()
            )
            .service(challenge_handler)
            .service(challenge_response_handler)
    })
    .bind(("127.0.0.1", 3002))?
    .run()
    .await
}
